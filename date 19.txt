Select query:
SELECT CustomerName, City FROM Customers;
SELECT * FROM Customers;

SELECT DISTINCT Statement:
SELECT DISTINCT Country FROM Customers;
SELECT COUNT(DISTINCT column_name) FROM Customers;

SQL WHERE Clause:
SELECT * FROM Customers WHERE Country='Mexico';->for text '' mostly sometimes ""
SELECT * FROM Customers WHERE CustomerID=1;->for number no quotes 
we can use select,update,delete with where class
operators used =,>,<,>=,<=,<>,!=,BETWEEN,LIKE,IN(similar to or)

ORDER BY Keyword

SELECT column1, column2, ...
FROM table_name
ORDER BY column1, column2, ... ASC|DESC;
For string values the ORDER BY keyword will order alphabetically
eg:SELECT * FROM Customers
ORDER BY Country, CustomerName;
it orders by Country, but if some rows have the same Country, it orders them by CustomerName

SQL AND Operator-displays a record if all the conditions are TRUE.
SQL OR Operator-displays a record if any the conditions are TRUE.
You can combine AND OR but use paranthesis
SELECT * FROM Customers
WHERE Country = 'Spain' AND (CustomerName LIKE 'G%' OR CustomerName LIKE 'R%');
Syntax:SELECT column1, column2, ...
FROM table_name
WHERE condition1 AND condition2 AND condition3 ...;

SQL OR
SELECT *
FROM Customers
WHERE Country = 'Germany' OR Country = 'Spain';
if you want to return all customers from Germany but also those from Spain


SQL NOT Operator:(NEGATIVE RESULT)

SELECT column1, column2, ...
FROM table_name
WHERE NOT condition;
Eg:SELECT * FROM Customers
WHERE NOT Country = 'Spain';
can be used with like,between,in,greater than, lesser than

SQL INSERT INTO Statement (2 ways to insert)
1.INSERT INTO table_name (column1, column2, column3, ...)
VALUES (value1, value2, value3, ...);
2.If you are adding values for all the columns of the table, you do not need to specify the column names in the SQL query
Syntax:INSERT INTO table_name
VALUES (value1, value2, value3, ...);


SQL NULL Values:
A field with a NULL value is a field with no value.
How to Test for NULL Values?We will have to use the IS NULL and IS NOT NULL operators instead.
Syntax:SELECT column_names
FROM table_name
WHERE column_name IS NULL;
Syntax:SELECT column_names
FROM table_name
WHERE column_name IS NOT NULL;
Tip: Always use IS NULL to look for NULL values.

SQL UPDATE Statement
UPDATE table_name
SET column1 = value1, column2 = value2, ...
WHERE condition;
If no where clause all column will be updated.

MySQL DELETE Statement:
DELETE FROM table_name WHERE condition;
DELETE FROM Customers WHERE CustomerName='Raju';->delete raju row only
DELETE FROM table_name;->Delete all records.


MySQL LIMIT Clause:(specify the number of records to return.)
SELECT column_name(s)
FROM table_name
WHERE condition
LIMIT number;

SELECT * FROM Customers
LIMIT 3 OFFSET 4;->skip the first 3 and show the next 4 records


SQL CREATE DB:
CREATE DATABASE databasename;
SHOW DATABASES;

SQL DROP DB:
DROP DATABASE databasename;

SQL CREATE TABLE:
CREATE TABLE Persons (
    PersonID int,
    LastName varchar(255),
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255)
);
Create new table based on existing table and fill old table value:
CREATE TABLE new_table_name AS
    SELECT column1, column2,... //columns that are needed
    FROM existing_table_name
    WHERE ....;  //where is optional

SQL DROP TABLE:

DROP TABLE table_name;->Delete entire table

MySQL TRUNCATE TABLE:
TRUNCATE TABLE table_name;->Delete only the data but not the table structure.

MySQL ALTER TABLE:(add,delete,modify)
alter-add
Syntax:ALTER TABLE table_name ADD column_name datatype;
Eg:ALTER TABLE Customers ADD Email varchar(255);

alter-drop
ALTER TABLE table_name DROP column_name ;
ALTER TABLE Customers DROP Email ;

Alter-modify
ALTER TABLE table_name MODIFY column_name datatype;
ALTER TABLE Persons MODIFY COLUMN DateOfBirth year;



Create constraint:(not null,unique,primary key,foreign key,check,default,create index)
CREATE TABLE table_name (
    column1 datatype constraint,
    column2 datatype constraint,
    column3 datatype constraint,
    ....
);


1.NOT NULL Constraint:

CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255) NOT NULL,
    Age int
);

ALTER TABLE Persons
MODIFY Age int NOT NULL;

2.UNIQUE Constraint:
CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    UNIQUE (ID)
);
unique columns can be null if not null constraint is not mentioned
for using unique in multiple columns:CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    CONSTRAINT UC_Person UNIQUE (ID,LastName)
);

ALTER TABLE Persons
ADD UNIQUE (ID);

ALTER TABLE Persons
ADD CONSTRAINT UC_Person UNIQUE (ID,LastName);	->UC_Person=constraint name

ALTER TABLE Persons
DROP INDEX UC_Person;

PRIMARY KEY Constraint:

CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    PRIMARY KEY (ID)
);

CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    CONSTRAINT PK_Person PRIMARY KEY (ID,LastName)
);

Note: In the example above there is only ONE PRIMARY KEY (PK_Person). However, the VALUE of the primary key is made up of TWO COLUMNS (ID + LastName).

ALTER TABLE Persons
ADD PRIMARY KEY (ID);


ALTER TABLE Persons
ADD CONSTRAINT PK_Person PRIMARY KEY (ID,LastName);

Note: If you use ALTER TABLE to add a primary key, the primary key column(s) must have been declared to not contain NULL values (when the table was first created).

ALTER TABLE Persons
DROP PRIMARY KEY;

FOREIGN KEY Constraint(used to prevent actions that would destroy links between tables.)
 foreign key is called the child table, and the table with the primary key is called the referenced or parent table.

CREATE TABLE child_table (
    column1 datatype,
    column2 datatype,
    ...
    FOREIGN KEY (child_column)
    REFERENCES parent_table(parent_column)
);

CREATE TABLE Orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    FOREIGN KEY (customer_id)
    REFERENCES Customers(id)
    ON DELETE CASCADE
);->This means deleting a customer will automatically delete their orders.

ALTER TABLE Orders
ADD CONSTRAINT FK_PersonOrder
FOREIGN KEY (PersonID) REFERENCES Persons(PersonID);

ALTER TABLE Orders
DROP FOREIGN KEY FK_PersonOrder;

CHECK Constraint:






JOIN:INNER JOIN:
SELECT column_name(s)
FROM table1
INNER JOIN table2
ON table1.column_name = table2.column_name;

SELECT Orders.OrderID, Customers.CustomerName
FROM Orders
INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID;

LEFT JOIN :(ALL record from left table +matching record from 
SELECT column_name(s)
FROM table1
LEFT JOIN table2
ON table1.column_name = table2.column_name;


SELECT Customers.CustomerName, Orders.OrderID
FROM Customers
LEFT JOIN Orders ON Customers.CustomerID = Orders.CustomerID
ORDER BY Customers.CustomerName;


RIGHT JOIN Keyword:
SELECT column_name(s)
FROM table1
RIGHT JOIN table2
ON table1.column_name = table2.column_name;

SELECT Orders.OrderID, Employees.LastName, Employees.FirstName
FROM Orders
RIGHT JOIN Employees ON Orders.EmployeeID = Employees.EmployeeID
ORDER BY Orders.OrderID;

CROSS JOIN:(returns all records from both tables (table1 and table2)).
SELECT column_name(s)
FROM table1
CROSS JOIN table2;

SELECT Customers.CustomerName, Orders.OrderID
FROM Customers
CROSS JOIN Orders;

Self Join:(regular join, but the table is joined with itself.)
SELECT column_name(s)
FROM table1 T1, table1 T2
WHERE condition;

SELECT A.CustomerName AS CustomerName1, B.CustomerName AS CustomerName2, A.City
FROM Customers A, Customers B
WHERE A.CustomerID <> B.CustomerID
AND A.City = B.City
ORDER BY A.City;

UNION Operator:
UNION->duplicates not present in o/p
UNION ALL->duplicates present i o/p
automatically removes duplicate rows from the result set.
Requirements:
Every SELECT statement within UNION must have the same number of columns
The columns must also have similar data types
The columns in every SELECT statement must also be in the same order

SELECT column_name(s) FROM table1
UNION
SELECT column_name(s) FROM table2;

SELECT City FROM Customers
UNION
SELECT City FROM Suppliers
ORDER BY City;

UNION ALL Operator:(including any duplicates.)
SELECT column_name(s) FROM table1
UNION ALL
SELECT column_name(s) FROM table2;

SELECT City FROM Customers
UNION ALL
SELECT City FROM Suppliers
ORDER BY City;

GROUP BY Statement:used with aggregrate statement
SELECT COUNT(CustomerID), Country
FROM Customers
GROUP BY Country;

HAVING Clause
The HAVING clause was added to SQL because the WHERE keyword cannot be used with aggregate functions.


SELECT column_name(s)
FROM table_name
WHERE condition
GROUP BY column_name(s)
HAVING condition
ORDER BY column_name(s);

SELECT COUNT(CustomerID), Country
FROM Customers
GROUP BY Country
HAVING COUNT(CustomerID) > 5;

EXISTS Operator:
The EXISTS operator is used to test for the existence of any record in a subquery.

The EXISTS operator returns TRUE if the subquery returns one or more records.
SELECT column_name(s)
FROM table_name
WHERE EXISTS
(SELECT column_name FROM table_name WHERE condition);

SELECT SupplierName
FROM Suppliers
WHERE EXISTS (SELECT ProductName FROM Products WHERE Products.SupplierID = Suppliers.supplierID AND Price < 20);



SQL FUNCTIONS:
select length('keerthika');->9
select length('keerthika\0');->10 \0 is will be considered as null (\0)=1 byte so 9+1=10
select upper('keer');
select lower('KEER');
select length(trim('  keer  '));
select trim('  keer  ');
select rtrim('  keer  ');
SELECT REPLACE('keerthika','ee','a'); -- strig,from_string,to_string
select substr('Keerthika Devi',9,3); -- string,start_position,length ->o/p:a D 
note:1 based indexing used
select empname,upper(empname) as up_empname from emptable;
SELECT UPPER(empname) AS up_empname FROM emptable;
select concat(firstname,'D',lastname)as name from student;
select right(name,3) from students; ->gives last 3 char of name column
select instr('Keerthika','th');->it will the position ;o/p:5
If not found return 0/NULL
select instr('Keerthika','z');->o/p:0
select reverse('Keerthika');
SELECT LPAD('123', 5, '0');->string,length,pad_string ;o/p:00123
SELECT RPAD('123', 5, '0');->string,length,pad_string ;o/p:12300
SELECT ABS(-900);->O/P:900
SELECT ROUND(34.6);->O/P:35
SELECT CEIL(34.4);->O/P:35
SELECT FLOOR(34.9);->O/P:34
SELECT MOD(23,3);->O/P:2
SELECT POWER(5,4);->O/P:625
SELECT SQRT(144);->O/P:12
SELECT SIGN(-90);->O/P:-1
SELECT SIGN(90);->O/P:1
SELECT SIGN(0);->O/P:0
SELECT TRUNCATE(67.896543,2);->O/P:67.89
SELECT TRUNCATE(RAND(),6)->Generates a random floating-point number between 0 and 1.
SELECT ROUND(RAND()*1000000);->FOR OTP GENERATION
SELECT NOW();
SELECT CURDATE();
SELECT CURTIME();
SELECT DATEDIFF('2025-02-05','2004-02-05'); o/p:7671 Sysntax:big date,small date ;date format:yyyy/mm/dd
SELECT DATE_ADD('2025-01-01', INTERVAL 10 DAY);o/p:2025-01-11
SELECT YEAR('2025-11-17') AS YearValue;->o/p YearValue 2025
SELECT MONTH('2025-11-17') ;->o/p 11
SELECT DAY('2025-11-17') ;->o/p 17

SELECT DAYNAME('2025-11-18');
SELECT DAYNAME(CURDATE());
SELECT DATE(NOW());
SELECT TIME(NOW());
SELECT YEAR(NOW());
SELECT YEAR('2004-02-05');


shoe create table table_name->to find the schema
SQL Aggregate Functions:op is always a single value
Aggregate functions are often used with the GROUP BY clause of the SELECT statement.
Aggregate functions ignore null values (except for COUNT(*)).
eg:
SaleID	Amount
1	100
2	NULL
3	200
4	300
5	NULL
SELECT COUNT(Amount) FROM Sales;->o/p:3
SELECT COUNT(*) FROM Sales;->o/p:5

SQL MIN() and MAX() Functions:
SELECT MIN(Price) as smallprice
FROM Products;
SELECT MAX(Price) as largestprice
FROM Products;

Note:When you use MIN() or MAX(), the returned column will not have a descriptive name. To give the column a descriptive name, use the AS keyword

MySQL COUNT(), AVG() and SUM() Functions:
SELECT COUNT(column_name) FROM table_name WHERE condition;
COUNT(*)->NULL VALUES COUNTED
SELECT AVG(column_name) FROM table_name WHERE condition;
SELECT SUM(column_name) FROM table_name WHERE condition;


To find execution of queries:
set profiling=1;
select productname from products where buyprice>(select avg(buyprice) from products) order by productname;
select *from offices;
show profiles;
show profile for query 8;

Index:
B+tree used->logarithmic values la Time complexity
Fast retrieval
But update(DML queries) takes time because we should update index also-drop index and do this

This will allow duplicates
CREATE INDEX index_name
ON table_name (column1, column2, ...);

This will not allow duplicates:
CREATE UNIQUE INDEX index_name
ON table_name (column1, column2, ...);
Drop index:
drop index index_name on table_name;
drop index id1 on emp;


Explain select* from emp where salary>5000;->gives details on table_name,index used,how many rows checked,joined used

Built-in function/udf(user defined function) will always return scalar values(single values)
Stored procedure may return 1/more values
deterministic-whatever same i/p same o/p eg:i/p =85 ;grade='A'
non-deterministic-changes always ;eg:now(),date()

stored procedure->call procedure_name()->execute
function->use select statement for calling like
select function_name(param1,param2);

Note:Select corresponds to Projection, from corresponds to Selection and where corresponds to cartesian product operations of Relational algebra.
